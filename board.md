# 게시판 만들기
1. 1강
   1. 핵심로직(Board)에서 no main -> runPrompt, runBoard() method에서 무한반복 입력기 돌리기
      1. 참고로 미션은.. Application.java에서
      2. 실행 기능을 가진 Main 클래스 만들어서 main메소드로 Board객체를 만들어 핵심로직 인스턴스 method 돌리기
      3. if분기별로 처리하기 -> **`help -> add(추가) -> list(조회)`** 순... -> 맨 마지막 분기에 안걸리는 예외처리하기
2. 2강 수정
   1. update시 입력받는 게시물번호는 index가 아니라 고유번호다 -> 고유번호도 데이터로서 add할 떄,넣어줘야한다.
      1. 앞에께 삭제되더라도 땡겨가는 일은 없어야한다.
   2. 고유번호 ->  autouincrement 구현 -> 그것을 저장하는 자료구조도 또 구현
   3. update시 입력받은 게시물고유번호로 -> 3 list의 index를 찾아야하는데
      1. my)list.indexOf(value)로 index를 찾을 수 있지만
      2. 강사는 어떤 값이 배열 어디에 위치(index)를 알 수없으니 for문으로 돌아서 검색해야 된다고 한다.
   4. update시 게시물을 찾다가 없을 수 도 있다. -> targetIndex에 초기화값(-1)이 그대로 있을 것이다 `초기화 값 활용`!!
      1. my) **수정(삭제)시 해당 데이터를 찾아야하며, index검색은 `찾았을 때 반복문밖에 챙겨둘 & 못찾을 것 대비 int -1`의 지역변수를 하나 만들어놓는다.** 
      2. **`for문으로 배열속 값 찾기`시에 -> 찾았는데 없을 때, 초기화 값으로 확인해주는 sense 활용~!!**
3. 3강 삭제
   1. 조회는 리팩토링 하기도 전에 미리 함수로 짜서 -> 수정 등에서 보여지개 한다.
   2. 삭제는 수정과 비슷하지만 쉽다.
      1. 수정, 삭제는 고유번호 선택하여 검색 -> 반복문통해 찾아 해당 index 없으면 초기화값활용해서 확인한 뒤 없다는 멘트 -> 수정/삭제후 원래 조회 띄워주기
      2. 수정/삭제시 고유번호 검색부분(getIndexOfArticle)도 중복으로 리팩토리 대상이다
      3. **리팩토링으로 for문 break가 메소드 안으로 왔다면 return으로 바로 변경해줄 것!!!**
         1. **메소드 안으로 들어왔다면, for에서 받검색시 찾았을 때 받아주는 변수도 필요없다 찾으면 바로 return**

4. 4강 삭제 + run()메소드 리팩토링
   1. 데이터가 2개이상 표현되는 단위는 무조건 묶은 class로 생각한다.
      1. class생성후 add부터 고쳐나간다.
      2. 묶더라도 저장은 class의 객체를 Arraylist에 순서대로 해줘야한다.
   2. new 클래스( 정의안해준, 생성자, 넣은 빨간줄); -> ctrl+. -> 생성자 편하게 추가해주기?
   3. **main에 돌아가는 runBoard()가 분기별로 코드가 길어진다. -> `분기별로 메소드로 빼준다!`**
      1. 코드 잘라내기(`continue, break 들어간 부분 제외`) -> 메소드명 적기 -> ctr + .
   4. 주의!) **수정시 id(게시물고유번호)는 입력(검색)받은 것 그대로, 새 객체에 써야함.**
   5. my) 밖에서 public 인스턴스메소드 runBoard()를 돌리더라도, 
      1. 인메로 돌린다? `객체`를 만들어서 사용함.-> 객체단위로 결과값, 데이터를 관리하는 인변은 편하게 사용된다.
      2. `인스턴스 변수`는 `객체 단위`로 관리되는 결과값이기 때문에, `객체`.`run`Board`()`에서는 항상 유지되니 편하게 선언하고 사용하면 된다.
         1. **인메로 run()정의 -> 객체만들어서 돌릴 예정 -> 인변 노상관, 객체단위로 돌아감 -> static안해줘도 됨.**
         2. **인메로 가동 -> `객체생성해서 쓰는` 객체단위 기능 -> static없어도 인변으로도 잘 사용된다.**
         3. **인메들 공통으로 쓸 변수 -> 인변으로 만들어도 된다. 인메는 객체단위로 돌아가기 때문에 -> 인변도 객체단위로 관리되는 변수기 때문!!**
   6. **early continue가 포함된 코드를 메소드 리팩토링 할 때**
      1. **early coninue -> `return`으로만** 바꿔주면 된다.
      2. 메소드내에서 early return에 안걸릴 경우, 추가처리가 되도록 작성되었다면, early return해서 나가도 괜찮다.
         3. **대신 ealry return후 나갔는데, 추가작동코드가 잇으면 안된다. 분기용 마지막 continue빼고는 다 메소드내에 있어야됨.**
   7. **update, delete 등에서 내부에서 list(`조회`)메소드가 사용된다면 -> 같이 리팩토링 `메소드안에 넣어준다!!`**
      1. **`추가 -> 조회 -> 부터  -> 수정 -> 삭제` 순으로 개발**하는 이유가 있다.
         1. 수정/삭제 시에 조회()의 메소드가 계속 쓰일 수 있기 때문

5. 5강 제목으로 검색 by String.contains
   1. 검색의 결과는 항상 `0개` or `복수개`가 나올 수 있다고 생각하자.
   2. **`<내부에 반복문을 도는 조회(출력)함수>`  list()를 `(조회 길이가변을 자동처리하도록)ArrayList를 받도록 파라미터와 함께 리팩토링`** 한다.
      1. **`인자로 list`를 주면, `전체`를 주면 전체를, `일부`를 주면 일부를, `1개를 주면 1개짜리 arraylist도` 그것만 출력시켜 줄 것이다!!**
      2. 전체 list, 일부list, 정렬된list, 1개, 0개 다 검색(반복문돌며 출력)가능해진다.
6. (테스트)초기 데이터 (만들기) 넣어주기
   1. run()메소드시작시, 미리 arraylist에 객체를 넣어주고, 넣어준만큼 데이터시작번호no를 옮겨준다.
   2. **인메run()의 첫시작 부분(초기데이터 넣어주기)가 메인로직을 앞에서 가린다면?**
      1. **인메run()시작부분보다 더 앞으로 빼주기 위해**
      2. **`인메사용을 위한 객체 생성`시 `생성자`에 초기코드(데이터 미리 넣는 코드)를 넣어준다**
      3. cf) `기능(=인메)`는 class에 정의하여 `class의 객체를 통해 발휘`해야한다. 그 때, 기능의 초반부 코드를 `기능 사용을 위해 생성되는 class객체`의 `생성자`에 넣어준다.
      4. cf) 객체는 `데이터묶음용` or `**기능사용용`** or `데이터 + 기능`까지 여러 용도가 있다.

7. 날짜, 작성자, 조회수 추가하기
   1. class에 묶은 데이터(변수)가 추가되었다면, 기존코드를 테스트데이터로 일단 채워놓고 시작한다.
   2. 날짜는 `오늘날짜구하기` -> Test.java에서 코드복붙해서 테스트 -> util패키지 Util클래스로 빼주기
      1. java8이후 java.time 의 `.LocalDate`가 사용됨 (필요시 .ZoneId까지)
      2. **LocalDate.now()의 기본형은 date타입인 LocalDate타입이지만 `DateTimeFormatter`를 적용하면**
         1. **1) `원하는 포맷`으로 + 2) `문자열로 변환`까지 2개가 동시**에 된다.
      3. **`포맷터 패턴`는 보통 getDate()함수들의 `파라미터`로 받아서 원하는대로 바뀌게 해주자.**
         1. list(반복문돌며 조회or출력)함수에 파라미터 = Arrayslist그 자체로 가변길이 처리됨
         2. 날짜얻는 함수에 파라미터 포맷터 패턴 -> 원하는 형태 문자열 날짜 처리됨.
      4. 유틸성 공유목적의 메소드만 static을 붙인다.
         1. static 메소드를 가지는 class는 **`관리할 결과값(상태, 인스턴스변수)가 없으므로` 항상 같은일만 반복**한다.
8. 게시물 상세보기(read)
   2. `조회수` 변수 -> 상세보기(read)와 관련되어, 구현될 때, `먼저++; 해서 올라간 hit를 보여`준다. **인변 객체 생성시 생성자에서 hit는 0으로 초기화함**
      1. `작성자` 변수 -> 로그인 기능 만들어야지 테스트 데이터(상수)`하드코딩` 없앨 수 있다.
   3. 상세보기 하는 이유
      1. 내용이 너무 길어서 상세보기 안하면, 일부만 보여짐 -> **`많은 내용`**을 보기 위해
      2. **상세보기로 들어와서만 할 수 있는 행위 `좋아요, 댓글, 조회수` 등의 처리**가 가능해짐
   4. id로 db(arraylist)속 index찾기 후 -> **index -1이 아니라서 return 안됬다면 상세보기됨 -> 조회수 1개 올린 뒤, 출력되어야한다.**
9. 회원 가입
   1. `작성자` 변수를 사용하려면, 회원가입이 구현되어야한다. -> 회원가입의 기능은 `저장`이며, `add`다.
   2. signup(회원가입)은 **저장이며, db없는 상태에서는 arraylist에 `add`다. -> **
   3. addArticle() 코드를 복붙해와서 참고해서 작성한다.
      1. article을 (title, body 등..) add하는 것을 -> ???Memober???(id, password, nickname 등...) add하는 것으로만 바뀐다.

10. 로그인(총 2번 커밋)
    1. 로그인구현 10-1
       1. 상세보기시 나타날 댓글, 좋아요 이외에 글쓰기 등을 로그인회원용으로 만든다.
       2. 로그인 한 상태라면, 콘솔옆에 아이디가 찍히게 만든다.
          1. ex> `명령어를 입력해주세요[hong123(홍길동)]`
       3. **`반복문 검색`시 (조건여러개를 한번에) `만족한 1번의 경우만 처리` 방법**
          1. 대부분 못찾았을 때다 -> if (조건) { } 에다가 `else를 달아서 처리하면 대부분이 사건이 발생`해버리는 오류
          2. 매 반복마다 못찾을 때 처리?(X) -> **`다돌아도 못찾는 경우`를 처리**하기 위해
             1. 반복문 검색 전, boolean변수로 false;로 선언
             2. 반복문 검색 찾은 1경우만, true;로 스위칭
             3. 반복문 끝나고나서야 `false;로 다돌아도 못찾음`을 검사해서 처리한다.
          3. 반복문검색시, 중복허용안된다고 가정하면, 찾자마자 boolean표시해주고, break로 빠져나와도 된다.
       4. `로그인처리`는 <다돌아도 못찾은경우>처리와 반대인 `<반복문검색 중 if찾는 부분>에서 처리`한다.
          1. 찾은경우? vs 다돌아도 못찾은 경우만 처리한다.
       5. 로그인이 필요한 기능들을 위하여, **로그아웃 전까지 로그인은 유지되어야한다**
          1. 안그러면, 로그인필요기능 선택할때마다 반복해서 로그인해야한다.
    2. 로그인구현 10-2: 로그인 유지를 위해
       1. **반복문검색 중 Id,Pw일치회원 -> `반복문영역{ }` 과 `login메서드영역{ }`을 벗어나서도 `찾은 회원정보가 유지`되어야하므로**
          1. -> **찾은 member를 run()진행단위 = 객체단위 = 1) `기능의 최상단인 결과값 관리변수인 인스턴스변수`에 담을 수 있게 그릇을 만들어 놓고**
          2. -> **2) `로그아웃 될대까지 유지`하도록 `login() {} > for 반복문{}영역에서 사라지기 저에 그릇에 담아둔다.`**
             1. 참고) class타입 = 객체타입 -> 값없이 선언 ->자바에서는  = null;로 세팅된다.
       2. 로그아웃전까지 `loginedMember가 구해진 상태` (== loginedMember변수가 null이 아닌상태)면~ `여러가지 처리`를 해줘야한다.
          1. run메소드 대표 안내문 if분기에 따라 다르게 보이게 됨.
          2. 앞으로 글쓰기, 상세보기 등은 로그인 했을 때만 되도록 처리해야한다.
      
11. Member 초기(테스트)데이터 집어넣기 -> **로그인도 시켜놓기**
    1. 테스트할 때마다 회원가입(add)시키는게 귀찮아서 하는 것.
    2. 기존 것makeTestData() 활용
       1. makeTestData() 정의 : arraylist(db)에 add하는 코드
       2. **runBoard() 인스턴스 `메서드 기능구현을 위한 객체`생성시 `생성자`에서 바로 작동하도록 한다.**
          1. run메서드 실행전에 (객체생성하자마자) 데이터가 들어가 있게 된다.
          2. run메서드 실행로직의 맨처음에 안줘도 되서 좋다.
       3. 테스트 데이터라도, 인자에 객체 생성 or 함수바로 호출 하지말고, 변수로 빼서 최적화시켜주기
    3. **signup(add) 뿐만 아니라 로그인 하는 것도 귀찮으니 `메서드 기능구현용객체. 생성자.`에서 초기데이터 넣어주던 메소드(makeTestData)에 `loginedMember = `를 초기 데이터에서 1개 꺼내 넣어주기**


12. 로그아웃: 로그인 유지 데이터(run메서드()속 인변)를 파기(null)하면 된다
    1. 조건: 로그인 한 상태일 때만, 로그아웃 가능. -> **로그인 안되어있으면, 먼저 로그인하라고 멘트날리기**
    2. **`~가 필요한 기능`(로그인이 필요한 메서드, `검사통과못하면 코드작동하면안됨`)들은 기능 작동전 `메서드 맨위에서 ~검사`를 `if조건 return`의 `종료필터링 검사`를 한다.**

13. 로그인필요기능들 처리: **메소드마다 진입필터링(<- 종료필터링) -> 메서드 내부에서는, `필터링된상태(로그인된상태)를 활용`해서 코드 변경해주기**
    3. 로그인검사 -> if return 종료필터링인데, 반복되니 메서드화 할려고 했지만
       1. **<if return 종료필터링 메서드화>는 끽해야 true, false 반환까지만 메서드화 하고, 종료는 해당 메서드영역에서 if <받은 true or false>에 의한 return을 여전히 해야한다**
       2. **`<진입후 if not return종료필터링>`을 -> isLoginCheck()메서드로 true/false가 나오는 상황이라면 `<진입전 if true시만 진입필터링>`으로 바꾸는게 낫다.**
          1. **if true 진입필터링은, t/f반환메서드내부에서 `false일때, 멘트(진입하려면 로그인 필요 등)`를 꼭 날려주자 ->  진입 못할시의 `else처리 할 필요가 없어진다`.**
    4. 로그인이 필요한 분기마다 `진입필터링 with isLoginCheck() + 진입못할시 멘트`로 로그인 검사를 해주자.
       1. **각 분기메서드 내부는 이제, `무조건 로그인 된 상태`가 된다.**
       2. **my) `검사통과필터링은 맥인 메소드 내부`는 `검사통과한 상태(로그인한 상태)를 활용해서 코드 작성`해야한다.**

    5. (추가) Member 데이터도 식별번호 추가 like 게시물 -> 게시물 쓸 때, member의 nickname, loginId보다는 고유번호id를 삽입하도록 변경
       1. loginId로 중복을 방지할 수 있지만, **수월하게 데이터를 관리하려면 1부터 1씩 증가하는 변수가 있는 것이 좋다**
       2. add시 Article에 멤버의 nickname, loginId가 아니라 고유번호를 넣도록 수정 -> Article 구조도 변경
    6. (추가2) Article nickname 데이터(변수) 추가: (고정된 값X)default "" -> `조회시 (변경하는, 변경된 데이터가 위치하는)member`를 통해 채워지도록 
       1. 게시물검색시 index반환 -> 게시물검색시 nickname까지 완성된 게시물반환 (index찾아오는 것은 없어짐)
          1. 게시물번호(input) -> 게시물검색 -> 찾아으면 받아놓고 memberId로 member정보(nickname)도 받기 -> 게시물완성후 게시물객체 반환
       2. memberId와 마찬가지로 **nickname**도 Article의 데이터로 포함시키기
          1. **nickname은 article에 빈값`""`으로 비워놓고, `해당 게시물 조회`(검색하는 read, search, update)`시 자동으로 코드가 삽입`하게 해준다.**
       3. **nickname은 어차피 member를 통한 조회후 출력만 되면 된다. `add시 필요없으므로, 인변으로 가지고 있되, 생셩자에서는 뺀다.`**
          1. 생성자에 가지고 있으면, 매번 글쓸때마다 `""`빈 문자열을 넣어야한다..
          2. **add시 default값이고, 조회시 매번 받아와야함.**
14. read 하위메뉴
    1. **함수끝나기전 `안내문+ scanner로 대기`** 걸어줘야 `메뉴`가 생긴다.
    2. `각 메뉴`는 `if분기`로 구현된다. -> 각 분기는 print or 주석으로만 먼저 채워둔다.
       1. 일부분기만 완성하고 넘어가자. 메뉴 잘넘어가나 test할 준비를 해야함.
    3. method내에서 또 길어진다 싶으면, `안내문 + 입력대기부터 싹다 ` 메소드로 뺀다
       1. **하위메뉴 이름 지을게 없다면 `xxxxProcess()`로 빼자.**
       2. 빼고 바로 테스트부터 해보자.
    4. **하위메뉴는 나가기전까지 상위 선택화면(상세보기) + 메뉴를 계속띄워줘야한다.**
       1. 댓글쓴다고 글 상세보기 화면에서 나가지지 않음. 그대로 있음.
       2. **`하위 안내문 -> 진입 테스트`가 완료되서야 while문에 넣어서 무한반복시킨다.**
       3. 분기중에 종료분기가 있다면 while (true)의 1순위 if break조건절이므로 -> 거기다 break를 넣어준다.

15. 댓글1- 등록: 댓글등록되면, 상세보기 + 등록된 댓글이 자동으로 보이게 한다.
    1. `입출력부터 완성`하고 -> 그담이 기능이다.
    2. 댓글이 `rbody만 받지만,` 1개만 받았다고 해서 1개의 데이터로 이루어진게 아니다! -> 출력시 보면 `여러개의 데이터`로 이루어짐
       1. 댓글작성자 변수 -> String writer가 아니라 `int memberId`
          1. 댓글작성자 -> **`타 객체(Member)에서 받는 정보(칼럼, 변수)는  직접적인 내용의 칼럼이 아니라 FK를 들고 있어야한다!!!**
       2. 현재 `Reply`클래스에는 4개의 데이터 변수가 존재함.
    3. Article(게시물)에 댓글 저장한다는 생각을 버려라 -> 1:n관계의 하나의 테이블(Class)다.
    4. 유틸메소드의 `인자 default값`을 메소드 파라미터에 해주는 것(python)이 아니라, `사용처에서 변수로 초기화해서 default 인자로 사용`한다.
    5. 댓글도 id는 변수=1 -> add시마다 변수++; 해주자.
       1. **add부터 하는 이유가 있는 듯..**
    6. 콘솔에서는 add하고 바로 list출력해줘야지 제대로 등록되었는지 확인이 된다.
    7. (추가)댓글구현2- (모든)댓글목록: 댓글등록후 상세보기 다시보여주고 + (모든)댓글목록 보여주기
       1. 리팩토링 단축키(alt+ctrl+m 2번) 활용하기
       2. **특정필드(id, number)등이 필요하면 ById, ByNumber를 메소드이름에 단다. 그게 아니면  동사+명사로**
       3. 메소드화시켜서 가져왔는데 파라미터로 쓸게 없을 때
          1. **호출하는 쪽으로 타고 타고 가서 발견될때까지 갔다가 계속 파라미터로 넘겨주기**
       4. 댓글 목록은 상세보기(메소드)에다가 이어서 for문으로 돌면서 같이 뿌려준다.
       5. reply든, article이든, `(중복/변경가능)nickname대신 memberId`를 필드로 가지고 있다가 -> 중복/변경가능한 nickname을 매번 조회해서 가져온다.
          1. **생성자에는 nickname이 없어 null이지만, 조회시마다 메소드로 새 데이터를 채워넣는다!!**
             1. **둘다 memberId외에 nickname 변수는 소지만하고, 생성자에는 없다!!!**
          2. nickname채워주는 메소드 작성시, replyArticle.memberId만 넘기지말고 객체를 통째로 넘겨줫다가, nickname이 채워진 객체를 통째로 받자!
       6. iter로 향상된 for문이라도, 변수명은 replyArticle -> currentReplyArticle 쓰려고 애써보자.
       7. article이든, reply든, get으로 객체가 요청될 때, nickname까지 완성한 뒤 return해줘야한다. 
          1. **객체 검색로직 직후에 nickname박는 로직도 같이 넣어줘야 완성된 객체가 반환된다.**
             1. `boardArticle`의 경우, article객체검색로직 -> nickname채우는 로직 -> 완성된 aritcle객체 반환이었지만
             2. `replyArticle`는 검색X 반환X -> 바로 출력하기 때문에 -> 출력직전에 nickname을 채워, 완성된 nickname이 출력되게 한다.
       8. **`if not null`에만 로직 작동 + `if문 바깥에서만 return` 하는 로직의 메소드 -> 파라미터가 null이면, 로직안거치고 바로 return null이 된다.**
    8. (추가)댓글구현3- Reply에 부모글번호도 보유 -> (특정)글에 대한 상세보기시 (해당)댓글만 보이게하기
       1. 댓글은 부모글이 반드시 필요하다. 모든 댓글 구현시만 잠시 빼놓은 것.
       2. **one의 번호를 fk로 받아야, `수많은 many 속에서` 해당하는 `1개 one에 대한 것들만 추릴` 수 있다.**
          1. fk(부모, 상위카테고리, one의 번호)를 받는 목적은 **many속에서도 일부만 추릴려고**
       3. **many속 `fk의 2가지 용도`를 깨달음..**
          1. **my) Reply속 memberId -> `정보조회용fk`** 
          2. **parentId -> `many(나)들 중 부모에 해당하는 것 일부만 추리는` 용도**
    9. (추가)Reply+Article 상카Clas(baesClass)생성후 상속 -> 다형성으로 일괄처리 리팩토링
       1. Article과 Reply는 `데이터저장용`Class로서 공통기능이 아닌 `공통변수`를 뽑아 상카Class(BaseClass)를 만든다.
       2. 각 클래스는 상카Class(BaseClass)를 상속한다.
       3. Base상카Class를 상속했다면, 공통변수들은 물려받게 되니 삭제한다.
       4. (공통변수 혹은 )공통기능 뿐만 아니라 **하카 객체들이 비슷하게 사용(파라미터등에서)되는 타Class 메소드들을 -> 다형성으로 처리해준다.**
          1. setArticleNickname() 복붙 -> setArticleNickname() 하나주석 + setReplyNickname()도 주석
          2. 복붙한 메소드 코드에서 Article이란 단어를 삭제
       5. 이제 하카객체 Article 파라미터 -> 하카 객체들 모두 받을 수 있게 상카Class, BaseClass객체를 받도록 한다  by 다형성
          1. 빨간줄 나는 곳들을 F8로 찾아다니면서 수정해준다. 하카객체 및 메소드들 모두
       6. 오호.. 다형성 리팩토링시, 상카객체를 return하는 메소들도 있으니, 메소드 호출처에서  = (작은것으로 형변환)은 필수적으로 들어간다.
    10. (추가) Class 이름변경 및 리팩토링
        1. BaseInfo -> BaseArticle
        2. 하위1: Article -> BoardArticle
        3. 하위2: Reply -> ReplyAricle
16. Member -> 우수회원개념 도입 -> 우수회원Class + 일반회원Class도 추가한 `하카Class`로 세분화해서 `instanceof`로 분기 나눠 따로 관리하기
    1. Member -> GeneralMember + SpecialMember 생성후, `기존에 있던 상카Class` Member 상속하기
    2. **기존에 있던 Member가 일반회원이라 생각하고, GeneralMember는 변수의 변화가 없다**
       1. **`우수회원`만 `[if instanceof로 따로 분기해서 관리]`하기 위해, 같은 레벨로서 GeneralMemeber도 곁다리로 생성되는 것이다!!**
       2. **my) 기능추가가 아닌 `변수추가`시에도 하카Class를 생성하며, `무변화Class도 하카Class로 추가 생성`해줘야 instanceof로 분기해서 관리할 수 있다.**
    3. 기존[ 회원가입 -> Member객체 생성했던 부분]으로 가서 세분화된 객체를 선택(사용자입력으로) 바꿔서 생성하고 저장해줘야한다.
       1. **그외에 테스트데이터 `new Member로 만든 부분`은 에러가 안난다. `에러안나는 부분(new 상카Class)들은 다 직접 찾아가서 바꿔줘야한다.** 
       2. **분기에 따라 new하카객체 생성시, 받는 것은 상카객체Type으로 다형성으로 편하게 받아준다!!**
       3. **데이터 저장도 기존 ArrayList<상카Classtype>이므로, add(하카객체)도 편하게 된다.**
    4. my) **하위카테고리class들을 분기별로 따로 관리하려고만들었더라도, -> `분기별 받아주는 변수` + `저장list`는 다 `상카classType`로 만들어서 편하게 받자.**
       1. `new Member로 만든 부분`은 상카Class객체 -> 하카Class로 세분화하더라도, 다형성에 의해 에러가 안나니 직접 가서 new하카객체()로 바꾸자.**
    5. **`instanceof`는 다형성에 의해 받은 하카객체 -> `다형성에 의해 1개list에 저장한 하카객체들`을 `꺼낼 때 구분이 안되는데, 그것을 분기`해주는 메소드다.**
       1. **`따로 관리용 하카Class객체들 -> 다형성으로 1곳에 밀어넣음 -> 꺼낼 때 어느 하카class객체인지 확인`으로 가장 중요한 부분**이다.
       2. **다형성list에서 `instanceof로 확인되었다면, (하카class) 형변환해서 하카객체에 새로 담기` 확실하게 해주기!!**
          1. 그래야 하위class만의 새로운 변수point (혹은 메소드)를 쓸 수 있게 된다.
       3. **그래도 `하카별 처리가 필요한 분기에서만` 새변수에 담아 하카만의 새로운변수, 기능을 사용하고 끝낸다.**
          1. **-> [if instanceof의 분기]빠져나오면, 새로 담은 변수 안쓰고, 기존 다형성 객체로 쭉 간다**
    6. (추가) 회원(하카class)별 인사 오버라이딩으로 다르게 처리
       1. (1) [instanceof] 다형성 상카classType List -> if instanceof 하카class객체별 분기 -> 분기별로 나눈뒤,  다르게 직접 처리
       2. **(2) [오버라이딩]  `하카class별 공통기능의 수정`(오버라이딩) 통해, 호출만 하면 알아서 하카class별 다르게 수정본으로 처리**
          1. **`공통기능이면(메서드이름만 같다면)` -> 굳이 instanceof로 객체종류를 따질 필요없다. 오버라이딩으로 공통기능 수정해놓으면 알아서 다르게 기능한다.**
          2. 즉, 회원별 인사**`객체별 다르게 기능하는 메소드`를 공통기능으로 넣고** -> 오버라이딩해서 객체별 수정만 -> 분기없이 일괄처리할 수 있다.
       3. [적용] `오버라이딩(공통기능 하카class별 수정사용)`으로 하위카테고리별 공통기능 다르게 처리되도록 적용
          1. **하위카테고리Class별(회원종류별)로 다르게 작동할 메소드를 **`같은이름의 공통기능`메소드로서 Member(상위카테고리class)에 정의**해준다.
             1. 상카Class에 공통기능으로서 메소드를 추가했으면 -> 하카Class 각각에 상속되어서 가지고 있을 것이다.
          2. 다형성으로 하카객체 섞어놓은 list에서 꺼낸, `다형성 상카객체(하카의 어느것인지 모름)에게는 바로 공통기능을 호출`하도록 한다.
             1. 이대로 실행하면, `하카별 공통기능 수정사용(=오버라이딩)`을 안했기 때문에, 하카별 구분이 없이 상카(부모)공통기능만 작동한다.
             2. 초기 테스트데이터에 하카1(일반회원), 하카2(우수회원) 종류별로 넣어두자
          3. 각 하위카테고리Class별로, 공통기능 메소드greeting()을 수정하는 @Override해서 쓰자.
             1. **공통기능으로서 일괄 메서드호출은 되지만, 내부내용은 수정한대로 알아서 처리된다.**
    7. my) 하위카테고리Class별 관리, 처리를 위한
       1. class -> 똑같은데 하위class, + 기능(변수)추가 하위class  등으로 세분함.
       2. 처리의 2가지 방법
          1. [if instanceof 분기] or 
          2. [공통기능으로 넣고 다형성-상위카테고리 객체에 담아 일괄처리하되, 오버라이딩을 통한 하위카테고리Class별 내부구현부 수정] : 이름이 같은 공통기능으로 올린 뒤, 수정해서 사용하면, if분기 없이 알아서 일괄처리된다. 

17. 좋아요
    1. 체크(**기능은 `add`(저장)부터!**) : 기능은 항상 add의(데이터생성 -> db저장)부터해야 -> 그 이후에 검사or출력(list)등이 나온다.
       1. Like클래스의 데이터 변수로는 3가지 정보가 필요하다
          1. 1) 어떤게시물의 좋아요인가? 2) 해당게시물에는 누가 체크했나? 3) 언제 눌렀나?(등록날짜)
       2. `체크` : Like도 like`객체`를 만든 뒤, <Like>타입의 arraylist에 `저장`(add)해야한다. 
    2. 체크해제(토글) 추가(`add(저장)`이후에, -> `db(list)에서 체크여부를 검사`가 가능해짐.)
       1. `체크여부`는 현재 likes라는 list에 add하였기 때문에, `list에 있냐없냐`로 분기를 나눌 수 있다.
       2. Like(체크여부)식별하는데에 게시물id, 회원id 2개가 동시에 다 필요하다.!
          1. **검색메소드, 검색반복문은 찾으면,   반복문위 변수=null에 할당이 아니라 return나가버리므로, 업데이트용 변수=null;은 필요없다.**
          2. **메소드의 null반환(maybe get검색용메소드) -> 나가서, 뒤쪽에 if null처리 추가로 해줘야한다**
          3. 사실 **list,db 검색용get메소드에서 null가능성이 있는 것이야말고, 체크여부에 따른 분기를 나누는 핵심로직이었다.**
    3. (추가) 좋아요를 article print시 같이 뿌려주도록 화면 반영하기
       1.add or remove결정할때도  -> 저장유무 = 체크유무 확인를 위해 like를 검색하고,
       2. print할때도 -> 저장유무 = 체크유무 확인를 위해 like를 검색한다.
       3. **좋아요는 누른 뒤 바로. 상세화면 출력을 다시 한번 해줘야, 다시 진입안해도 확인된다.**
       4. 체크유무 출력(하트 색깔)이 완료되면 -> 실제 좋아요 갯수 출력도 처리해준다.
          1. (내가)체크유무(하트색) : 게시글id, 로그인사람id 2개의 식별자를 통해, 내가 만든 Like객체가 arraylist에 들어가 있는지 확인
             1. 검색get메소드의 결과가 null이면, `내가` && `해당글`에 좋아요 안누른 상태다!
          2. (모든사람이 누른)좋아요 수 : 게시글id 1개의 식별자로 몇개의 Like객체가 arraylist에 들어가 있는지 확인
       
18. 정렬기능 추가
    1. Collections.sort( DB인 list, ) + Comparator 를 이용하며, `정렬대상(기준)`(여기서 정해야함 -> 번호, 조회수) 과 `정렬방법`(오름차순, 내림차순)을 정해야한다.
       1. Comparator는 interface라서 class로 구현체를 만들고, `compare`메서드를 오버라이딩해서 그 기준을 정해줘야한다.
       2. 먼저 틀을 만들고 `if ( 바꿀 분기 ) { return 1; } return -1;` -> return 0은 아예 무시하자, 자리바끼는 기준인 듯
       3. 언제 서로 바꿀지=`왼쪽을 언제 오른쪽으로 보낼지`로 생각하여,  `왼쪽객체를 기준`으로 `언제 오른쪽으로 보낼지`를 작성해야한다. 
          1. 왼쪽객체. 기준숫자변수가 (오른쪽보다) `왼쪽이 클때 오른쪽으로 보낸다`? if(`o1.hit >` o2.hit  ) {return 1;}-> `오름차순`이다.
          2. return -1; 그반대.. 왼쪽이 작거나 같으면 자리안바꾼다. 왼쪽 그대로 둔다.
          3. 왼쪽이 클때, (오른쪽으로)보내면(return 1;)? `오름차순`
             1. 왼쪽이 작을때 보낸다면? `내림차순`
       4. 구현체 객체를 sort()의 2번째 인자로 구현체 객체 `new XXXXComparator()`를 주면, `특정변수`기준으로 `오름차순`정렬이 되어버린다.
          1. 일단은, 기준 무시하고 hit 조회수로 구현을 해보는 것
    2. (추가) Comparator구현체 객체를 sort() 2번째 인자로 사용하는 상황에서, `생성자의 파라미터로 입력받은 target(변수), type(정렬방법)받아서` 구현체 객체 생성시 사용해서 생성하기
       1. 우리는 `구현체객체를 생성`해서 정렬 기준으로 사용한다.
          1. 구현체 [객체가 생성되기 전] 에, 내부에서 작성에 이용된 뒤 -> 객체로 나와서 기준으로 사용되어야한다.
          2. 객체생성 전에 필요한 정보를, 생성자의 파라미터로 준다면 -> 생성자에 추가 -> this.인스턴스변수에서도 인변생성 및 받아줘야한다.
       2. 분기에 따라 compare의 분기를 결정짓는 변수가 달라져야하는데, 이것은 바로 분기로 못꺼낸다
          1. 분기를 결정짓는 조건변수를 파라미터로 받은, 함수로 만들어서, 각 변수꺼낼때마다의 로직을 if if 일일히 다 적어줘야함
          2. 각 compare의 기준이 되는 변수를 꺼내는 분기를 만들고, `compare가 받는 것은 return 1 아니면 -1이기 때문`에
          3. 우리만 알도록 기준변수 결정 -> 그 때마다 return 1, -1; 되도록 짜준다.
          4. 1 or -1로 나와서는, 정렬방법이 적용되도록 if분기에 따라 -1을 곱해서 compare에 반환해준다.
19. 페이징
    1. 바로 하면 어려우니, Test class 만들어서 연습하고 들어간다. -> [PagingTest.java]
       1. 어려운 기능은 먼저, Test에 구현해보고 적용한다.
       2. 출력문부터 하드코딩 따라하면서 어딜 동적으로 만들지 고민해본다
          1. 연속한 숫자 -> for문으로 대체 -> 시작숫자는 나중에 int i를 동적으로
          2. [1] 가 씌워진 숫자도 동적으로 바꿔야한다. -> for문안에서 if분기( i == currentPageNo)로 해당하는 숫자에 씌우게 한다.
             **1. `동적으로 바뀔 부분은 변수로 선언` -> 입력분기에 따라 증감 ++, --으로 변하게 된다.**
       3. 페이징은, 사용자로부터 이전 or 다음 등의 명령을 입력받아야한다. 
          1. 입력에 따라 currentPageNo를 ++ 혹은 -- 해준다.
       4. 페이지블럭 1~5 -> 6~10 이것도 나중에 변수처리해줘야한다.
       5. 출력 -> 이전or다음 [] 입력받기 -> 다시 출력시키고 싶다면
          1. 계속 반복된다면, 변수제외 while (true)로 다씌운다.(break 조건 아직 생각말고, 입력받아야해서 멈추면서 진행된다.)
             1. **무한반복문을 씌울 때, `if break()`도 좋지만, `scanner의 사용자입력으로 인한 대기`가 있다면 편하게 씌우고 처리한다. -> 특정값 입력시 break 검사하면 되니..**
                1. 입력받은 후 break검사하도록 아마 차후에 작성할 듯?
             2. 만약 딱 1번만 추가 출력하고 싶다면, 출력코드만 한번더 호출되게한다.
    2. 현재페이지번호 -> 1부터 시작해서, 사용자입력(이전/다음)으로 업데이트 된다.
       1. `현재 페이지번호`로  -> `현재 페이지블럭 번호`를 구한다
          - **현재페이지번호 / 5(~~페이지당보여질 갯수~~ `블럭당 보여질 페이지 갯수`) -> 올림**
          - (int) Math.ceil((double) currentPageNo /5);
            - **int / int 나눔시 하나는 double로 형변호  ->  올림 -> 다시 int변환**
          - **종속관계이므로 최초생성되고 업데이트를 `부모의 선언부 ~ 업데이트 되는 사이에 들어가야됨.` ->  while문 안에 들어가서 생성후 업데이트 계속 된다.**
       2. `현재 페이지블럭 번호`로  -> 페이지블럭 `시작번호`, `끝번호`를 구한다.
          - 1(`-> 1페이지를 n-1으로 0 만들생각`)부터 시작하는 페이지블럭번호라면 `5*(n-1)+1` ~ `5*(n)`으로 구한다.
          - 알아내서, for문의 시작과 끝에 주면 된다.
          - **종속관계이므로, 업데이트되는 곳 밑에다가 적어준다.**
    3. 현재페이지번호 -> 페이지당 보여질 갯수(이미 3으로 정함)만큼 짤라서 보여지도록 출력 for문 변수 업데이트
       1. 현재페이지번호 -> 블럭당 보여질 페이지 갯수(이미정5) -> (`페이지 블럭 번호`) 구하는 것과 별개로 -> 블럭 속 `1부터` 시작하는 `페이지 시작번호`: 5*(n-1) `+ 1`  
       2. **현재페이지번호 -> 페이지당 보여질 게시물 갯수 (이미정3) -> `0부터` 데이터 뽑아올 `index 시작번호`:  3*(n-1)**
       3. **my) 입력으로 업데이트되는 `시작의 상징 현재페이지번호` -> 1) (블보페갯:5정)블럭당 보여질 1시작 페이지시작번호  + 2) (페보갯:3정) 페이지당 보여질 0시작 for문index시작번호**
          1. 둘다 시작의 상징 `현재페이지번호`로 + 보여질갯수만 정해져있으면 -> 개별로 각각 뽑아낼 수 있다.
    4. 게시판에 페이지 번호 출력후 page()분기 만들어서 반복되도록 함.
       1. PagingTest 클래스의 Main에서, 변수들만 모조리 다 빼서, Pagination 클래스로 옮긴다.
       2. 메인로직인 Board클래스로 가서, pagination객체 생성후 -> 출력담당 list()를 수정할 준비를 한다.
          1. list()라는 메서드들안에서 편하게 쓰려면, 클래스 가장 위인 인스턴스변수로 선언해주고 시작한다.
       3. list() 출력메서드 맨 밑에 페이지 출력하도록 해주고, 변수를 클래스의 객체에서 뽑아오도록한다.
          1. 계산식으로 만들어진 변수들은... 객체 생성이후 업데이트가 안될듯?
          2. **[계산으로 만들어지는 변수들] == [부모변수 업데이트시 다 업데이트 한번 더 해줘야하는 변수들]이다.**
             1. 연산처리, 계산 등은 **메서드가 한다.**
       4. Pagination클래스내 `아래 5개의 연산처리, 계산, 업데이트가 필요한 변수` **`메서드화 시켜서, 호출로 그때그때마다 처리되어 업데이트 된 뒤 값을 return`하도록 하고 -> `필요한 곳에 제공`해야한다..**
          1. `while문에서 매번` 업데이트되던 계산식을 가진 변수 ->  -> return 메서드화 -> 필요한 곳에서 메서드 호출
          2. my) while문 내부에서 사용되던 업데이트 변수는, 밖으로 나올 땐, 메소드화가 되어야한다. 업데이트 연산처리는 바깥변수에선 1회 이후로 안되기 때문
             1. 한 변수의 변화에 따라 종속적으로 업데이트되어야하는 변수들은
             2. 메서드화해서, 필요한 곳에 메서드를 호출하는 식으로 바꾼다.
             3. 현재페이지번호 변화에 따른 -> 연산처리, 업데이트되는 종속 변수를 메서드화
          3. 클래스내 무지성으로 모은 변수들 -> 메서드화 시킨 메서드()호출로 바꿔준다.
       5. 페이징시 문자열 숫자를 파싱하는 부분 올바른 입력숫자 입력될대까지 무한반복되게 예외처리를 해준다.
          1. try에서 parseInt시도 -> 성공시 break
          2. catch에서는 그냥 흘러가도록 해서 while (true) 무한반복되게 
             1. 하면, 올바른 값 입력까지 무한으로 입력받을 수 있다.
          3. 메서드()는 파라미터없이 내부반복문에서 스캐너매번 호출 -> 올바른 값 입력까지 무한입력받고, parsing된 int를 반환하도록 메서드화 해서-> 메서드로 대체하여 pageCommand=에 할당한다.
          4. parseInt를 쓰는 모든 곳을 메서드 inputIntData() 로 변환한다.
20. 파일 입출력
    1. 날짜, 랜덤숫자처럼 파일 입출력도 Util패키지에 새로운 클래스 `FileManager`로 만든다.
    2. 



## 기능 목록
- add(추가) ->list(출력) -> test data -> update(수정)  -> delete(삭제) -> search(검색) -> add2(데이터 추가, 날짜Util) -> read(상세보기+조회수변수) -> signup(회원Class의 객체를 arraylist에 add) -> login-1(Id, Pw확인구현) -> login-2(로그인 유지) -> test 회원 data 자동 생성 및 로그인시켜놓기 
- logout -> login필요기능들 처리 -> member 식별번호 추가 ->  검색을 index->Article객체로 반환하도록 수정 + nickname변수를 Article에 추가하되, 생성자에선X -> Add시 노필요 default값만 유지하다가 조회시 Member에서 항상 최신값 받아오기
- read(상세보기) 하위메뉴 -> 댓글 등록(add, 부모글정보X) -> (부모글정보X, 모든) 댓글 목록 -> Reply에 부모글번호도 보유 -> (특정)글에 대한 상세보기시 (해당)댓글만 보이게하기
- Reply와 Article 공통기능 뽑아서 상카Class생성후 상속 -> 다형성으로 ~~일괄처리~~ 하카객체 사용 비슷한 메소드 1개로 통합 리팩토링 - 상카Class 및 그에 따른 하카Class들 이름 리팩토링 -> 
- member를 하카Class로 나눠서 일반회원 + 우수회원 나눠서 관리하기(다형성 -> 꺼낼땐 instanceof +  형변환후 새변수에 담아 분기안에서만 사용하고 끝냄) -> 회원별 인사를 분기 없이 오버라이딩으로 처리 
- 좋아요1(체크, add) -> 좋아요2(체크해제도 되도록, add이후 검사)
- 정렬기능(sort명령어, hit변수&&오름차순으로만 구현) -> 정렬 기준 및 방법 선택가능하도록 Comparator구현
- 페이징 기능1 - 일단 번호 기능만 만들기(이미 정해진 ~~페보갯~~ `블럭당 보여질 페이지 갯수`으로 돌리는 `for문`안에서 `현재 페이지번호`를 동적으로 표시되게 만들기)
- 페이징 기능2 - `현재페이지번호` + (이미정해진)  ~~페이지당 보여질 갯수~~ `블럭당 보여질 페이지 갯수`로 -> `현재 페이지블럭 번호`을 알 수 있음.
  - 페이지블럭번호를 알면 -> `페이지블럭 시작번호 , 끝번호`를 쉽게 안다. -> 출력for문의 시작, 끝번호로 지정해준다.
- 페이징 기능3 - 현재 페이지에 맞는 아이템 개수와 목록 출력
  - `현재페이지번호` -> 페이지당 보여질 갯수3을 정해놓으면 -> for문으로 돌리면서 item꺼내올 `0시작 index 시작번호`를 구할 수 있다.
- 페이징 기능4 - 게시판에 페이징 반영
- 페이징 기능5 - 페이징 예외처리
- 파일입출력1 - 

## 요구사항 - 페이징
- 게시물 페이징 기능 : 게시물이 많아지면 한 화면에 모든 게시물을 출력하기가 부담스럽습니다. 페이지를 만들어 한 페이지당 게시물을 3개씩 보여주세요. 페이지 기능은 원하는 페이지 이동, 다음 페이지 이동, 이전 페이지 이동으로 사용하도록 하겠습니다. 페이지의 개수가 많을 때는 한 블록에 페이지를 5개씩 보여주도록 하겠습니다.

- 명령어 : page
- 기능 :
   - 전체게시물을 페이지당 3개씩 출력.
   - 페이징 이동 기능을 선택 가능. (1 : 이전,  2 : 다음,  3 : 선택,  4 : 뒤로가기)

- 입출력예시 :
```
명령어를 입력해주세요 : page
번호 : 1
제목 : *제목1
작성자 : 작성자1
조회수 : 10
좋아요 : 3
================
번호 : 2
제목 : 제목1
작성자 : 작성자1
조회수 : 56
좋아요 : 6
================
번호 : 3
제목 : 제목2
작성자 : 작성자2
조회수 : 100
좋아요 : 2
================
[1] 2 3 4 5 >>
페이징 명령어를 입력해주세요 ((1. 이전,  2. 다음,  3. 선택,  4. 뒤로가기): 2

번호 : 4
제목 : 제목4
작성자 : 작성자4
조회수 : 10
좋아요 : 3
================
번호 : 5
제목 : 제목5
작성자 : 작성자5
조회수 : 56
좋아요 : 6
================
번호 : 6
제목 : 제목6
작성자 : 작성자6
조회수 : 100
좋아요 : 2
================
1 [2] 3 4 5 >>
페이징 명령어를 입력해주세요 ((1. 이전,  2. 다음,  3. 선택,  4. 뒤로가기): 1

번호 : 1
제목 : 제목1
작성자 : 작성자1
조회수 : 10
좋아요 : 3
================
번호 : 2
제목 : 제목1
작성자 : 작성자1
조회수 : 56
좋아요 : 6
================
번호 : 3
제목 : 제목2
작성자 : 작성자2
조회수 : 100
좋아요 : 2
================
[1] 2 3 4 5 >>
페이징 명령*어를 입력해주세요 ((1. 이전,  2. 다음,  3. 선택,  4. 뒤로가기): 3

이동하실 페이지 번호를 입력해주세요 : 4
번호 : 10
제목 : 제목10
작성자 : 작성자10
조회수 : 10
좋아요 : 3
================
번호 : 11
제목 : 제목11
작성자 : 작성자11
조회수 : 56
좋아요 : 6
================
번호 : 12
제목 : 제목12
작성자 : 작성자12
조회수 : 100
좋아요 : 2
================
1 2 3 [4] 5 >>
````
