# 게시판 만들기
1. 1강
   1. 핵심로직(Board)에서 no main -> runPrompt, runBoard() method에서 무한반복 입력기 돌리기
      1. 참고로 미션은.. Application.java에서
      2. 실행 기능을 가진 Main 클래스 만들어서 main메소드로 Board객체를 만들어 핵심로직 인스턴스 method 돌리기
      3. if분기별로 처리하기 -> **`help -> add(추가) -> list(조회)`** 순... -> 맨 마지막 분기에 안걸리는 예외처리하기
2. 2강 수정
   1. update시 입력받는 게시물번호는 index가 아니라 고유번호다 -> 고유번호도 데이터로서 add할 떄,넣어줘야한다.
      1. 앞에께 삭제되더라도 땡겨가는 일은 없어야한다.
   2. 고유번호 ->  autouincrement 구현 -> 그것을 저장하는 자료구조도 또 구현
   3. update시 입력받은 게시물고유번호로 -> 3 list의 index를 찾아야하는데
      1. my)list.indexOf(value)로 index를 찾을 수 있지만
      2. 강사는 어떤 값이 배열 어디에 위치(index)를 알 수없으니 for문으로 돌아서 검색해야 된다고 한다.
   4. update시 게시물을 찾다가 없을 수 도 있다. -> targetIndex에 초기화값(-1)이 그대로 있을 것이다 `초기화 값 활용`!!
      1. my) **수정(삭제)시 해당 데이터를 찾아야하며, index검색은 `찾았을 때 반복문밖에 챙겨둘 & 못찾을 것 대비 int -1`의 지역변수를 하나 만들어놓는다.** 
      2. **`for문으로 배열속 값 찾기`시에 -> 찾았는데 없을 때, 초기화 값으로 확인해주는 sense 활용~!!**
3. 3강 삭제
   1. 조회는 리팩토링 하기도 전에 미리 함수로 짜서 -> 수정 등에서 보여지개 한다.
   2. 삭제는 수정과 비슷하지만 쉽다.
      1. 수정, 삭제는 고유번호 선택하여 검색 -> 반복문통해 찾아 해당 index 없으면 초기화값활용해서 확인한 뒤 없다는 멘트 -> 수정/삭제후 원래 조회 띄워주기
      2. 수정/삭제시 고유번호 검색부분(getIndexOfArticle)도 중복으로 리팩토리 대상이다
      3. **리팩토링으로 for문 break가 메소드 안으로 왔다면 return으로 바로 변경해줄 것!!!**
         1. **메소드 안으로 들어왔다면, for에서 받검색시 찾았을 때 받아주는 변수도 필요없다 찾으면 바로 return**

4. 4강 삭제 + run()메소드 리팩토링
   1. 데이터가 2개이상 표현되는 단위는 무조건 묶은 class로 생각한다.
      1. class생성후 add부터 고쳐나간다.
      2. 묶더라도 저장은 class의 객체를 Arraylist에 순서대로 해줘야한다.
   2. new 클래스( 정의안해준, 생성자, 넣은 빨간줄); -> ctrl+. -> 생성자 편하게 추가해주기?
   3. **main에 돌아가는 runBoard()가 분기별로 코드가 길어진다. -> `분기별로 메소드로 빼준다!`**
      1. 코드 잘라내기(`continue, break 들어간 부분 제외`) -> 메소드명 적기 -> ctr + .
   4. 주의!) **수정시 id(게시물고유번호)는 입력(검색)받은 것 그대로, 새 객체에 써야함.**
   5. my) 밖에서 public 인스턴스메소드 runBoard()를 돌리더라도, 
      1. 인메로 돌린다? `객체`를 만들어서 사용함.-> 객체단위로 결과값, 데이터를 관리하는 인변은 편하게 사용된다.
      2. `인스턴스 변수`는 `객체 단위`로 관리되는 결과값이기 때문에, `객체`.`run`Board`()`에서는 항상 유지되니 편하게 선언하고 사용하면 된다.
         1. **인메로 run()정의 -> 객체만들어서 돌릴 예정 -> 인변 노상관, 객체단위로 돌아감 -> static안해줘도 됨.**
         2. **인메로 가동 -> `객체생성해서 쓰는` 객체단위 기능 -> static없어도 인변으로도 잘 사용된다.**
         3. **인메들 공통으로 쓸 변수 -> 인변으로 만들어도 된다. 인메는 객체단위로 돌아가기 때문에 -> 인변도 객체단위로 관리되는 변수기 때문!!**
   6. **early continue가 포함된 코드를 메소드 리팩토링 할 때**
      1. **early coninue -> `return`으로만** 바꿔주면 된다.
      2. 메소드내에서 early return에 안걸릴 경우, 추가처리가 되도록 작성되었다면, early return해서 나가도 괜찮다.
         3. **대신 ealry return후 나갔는데, 추가작동코드가 잇으면 안된다. 분기용 마지막 continue빼고는 다 메소드내에 있어야됨.**
   7. **update, delete 등에서 내부에서 list(`조회`)메소드가 사용된다면 -> 같이 리팩토링 `메소드안에 넣어준다!!`**
      1. **`추가 -> 조회 -> 부터  -> 수정 -> 삭제` 순으로 개발**하는 이유가 있다.
         1. 수정/삭제 시에 조회()의 메소드가 계속 쓰일 수 있기 때문

5. 5강 제목으로 검색 by String.contains
   1. 검색의 결과는 항상 `0개` or `복수개`가 나올 수 있다고 생각하자.
   2. **`<내부에 반복문을 도는 조회(출력)함수>`  list()를 `(조회 길이가변을 자동처리하도록)ArrayList를 받도록 파라미터와 함께 리팩토링`** 한다.
      1. **`인자로 list`를 주면, `전체`를 주면 전체를, `일부`를 주면 일부를, `1개를 주면 1개짜리 arraylist도` 그것만 출력시켜 줄 것이다!!**
      2. 전체 list, 일부list, 정렬된list, 1개, 0개 다 검색(반복문돌며 출력)가능해진다.
6. (테스트)초기 데이터 (만들기) 넣어주기
   1. run()메소드시작시, 미리 arraylist에 객체를 넣어주고, 넣어준만큼 데이터시작번호no를 옮겨준다.
   2. **인메run()의 첫시작 부분(초기데이터 넣어주기)가 메인로직을 앞에서 가린다면?**
      1. **인메run()시작부분보다 더 앞으로 빼주기 위해**
      2. **`인메사용을 위한 객체 생성`시 `생성자`에 초기코드(데이터 미리 넣는 코드)를 넣어준다**
      3. cf) `기능(=인메)`는 class에 정의하여 `class의 객체를 통해 발휘`해야한다. 그 때, 기능의 초반부 코드를 `기능 사용을 위해 생성되는 class객체`의 `생성자`에 넣어준다.
      4. cf) 객체는 `데이터묶음용` or `**기능사용용`** or `데이터 + 기능`까지 여러 용도가 있다.

7. 날짜, 작성자, 조회수 추가하기
   1. class에 묶은 데이터(변수)가 추가되었다면, 기존코드를 테스트데이터로 일단 채워놓고 시작한다.
   2. 날짜는 `오늘날짜구하기` -> Test.java에서 코드복붙해서 테스트 -> util패키지 Util클래스로 빼주기
      1. java8이후 java.time 의 `.LocalDate`가 사용됨 (필요시 .ZoneId까지)
      2. **LocalDate.now()의 기본형은 date타입인 LocalDate타입이지만 `DateTimeFormatter`를 적용하면**
         1. **1) `원하는 포맷`으로 + 2) `문자열로 변환`까지 2개가 동시**에 된다.
      3. **`포맷터 패턴`는 보통 getDate()함수들의 `파라미터`로 받아서 원하는대로 바뀌게 해주자.**
         1. list(반복문돌며 조회or출력)함수에 파라미터 = Arrayslist그 자체로 가변길이 처리됨
         2. 날짜얻는 함수에 파라미터 포맷터 패턴 -> 원하는 형태 문자열 날짜 처리됨.
      4. 유틸성 공유목적의 메소드만 static을 붙인다.
         1. static 메소드를 가지는 class는 **`관리할 결과값(상태, 인스턴스변수)가 없으므로` 항상 같은일만 반복**한다.
8. 게시물 상세보기(read)
   2. `조회수` 변수 -> 상세보기(read)와 관련되어, 구현될 때, `먼저++; 해서 올라간 hit를 보여`준다. **인변 객체 생성시 생성자에서 hit는 0으로 초기화함**
      1. `작성자` 변수 -> 로그인 기능 만들어야지 테스트 데이터(상수)`하드코딩` 없앨 수 있다.
   3. 상세보기 하는 이유
      1. 내용이 너무 길어서 상세보기 안하면, 일부만 보여짐 -> **`많은 내용`**을 보기 위해
      2. **상세보기로 들어와서만 할 수 있는 행위 `좋아요, 댓글, 조회수` 등의 처리**가 가능해짐
   4. id로 db(arraylist)속 index찾기 후 -> **index -1이 아니라서 return 안됬다면 상세보기됨 -> 조회수 1개 올린 뒤, 출력되어야한다.**
9. 회원 가입
   1. `작성자` 변수를 사용하려면, 회원가입이 구현되어야한다. -> 회원가입의 기능은 `저장`이며, `add`다.
   2. signup(회원가입)은 **저장이며, db없는 상태에서는 arraylist에 `add`다. -> **
   3. addArticle() 코드를 복붙해와서 참고해서 작성한다.
      1. article을 (title, body 등..) add하는 것을 -> ???Memober???(id, password, nickname 등...) add하는 것으로만 바뀐다.

10. 로그인(총 2번 커밋)
    1. 로그인구현 10-1
       1. 상세보기시 나타날 댓글, 좋아요 이외에 글쓰기 등을 로그인회원용으로 만든다.
       2. 로그인 한 상태라면, 콘솔옆에 아이디가 찍히게 만든다.
          1. ex> `명령어를 입력해주세요[hong123(홍길동)]`
       3. **`반복문 검색`시 (조건여러개를 한번에) `만족한 1번의 경우만 처리` 방법**
          1. 대부분 못찾았을 때다 -> if (조건) { } 에다가 `else를 달아서 처리하면 대부분이 사건이 발생`해버리는 오류
          2. 매 반복마다 못찾을 때 처리?(X) -> **`다돌아도 못찾는 경우`를 처리**하기 위해
             1. 반복문 검색 전, boolean변수로 false;로 선언
             2. 반복문 검색 찾은 1경우만, true;로 스위칭
             3. 반복문 끝나고나서야 `false;로 다돌아도 못찾음`을 검사해서 처리한다.
          3. 반복문검색시, 중복허용안된다고 가정하면, 찾자마자 boolean표시해주고, break로 빠져나와도 된다.
       4. `로그인처리`는 <다돌아도 못찾은경우>처리와 반대인 `<반복문검색 중 if찾는 부분>에서 처리`한다.
          1. 찾은경우? vs 다돌아도 못찾은 경우만 처리한다.
       5. 로그인이 필요한 기능들을 위하여, **로그아웃 전까지 로그인은 유지되어야한다**
          1. 안그러면, 로그인필요기능 선택할때마다 반복해서 로그인해야한다.
    2. 로그인구현 10-2: 로그인 유지를 위해
       1. **반복문검색 중 Id,Pw일치회원 -> `반복문영역{ }` 과 `login메서드영역{ }`을 벗어나서도 `찾은 회원정보가 유지`되어야하므로**
          1. -> **찾은 member를 run()진행단위 = 객체단위 = 1) `기능의 최상단인 결과값 관리변수인 인스턴스변수`에 담을 수 있게 그릇을 만들어 놓고**
          2. -> **2) `로그아웃 될대까지 유지`하도록 `login() {} > for 반복문{}영역에서 사라지기 저에 그릇에 담아둔다.`**
             1. 참고) class타입 = 객체타입 -> 값없이 선언 ->자바에서는  = null;로 세팅된다.
       2. 로그아웃전까지 `loginedMember가 구해진 상태` (== loginedMember변수가 null이 아닌상태)면~ `여러가지 처리`를 해줘야한다.
          1. run메소드 대표 안내문 if분기에 따라 다르게 보이게 됨.
          2. 앞으로 글쓰기, 상세보기 등은 로그인 했을 때만 되도록 처리해야한다.
      


## 기능 목록
- add(추가) ->list(출력) -> update(수정) -> delete(삭제) -> search(검색) -> add2(데이터 추가, 날짜Util) -> read(상세보기+조회수변수) -> signup(회원Class의 객체를 arraylist에 add) -> login-1(Id, Pw확인구현)  

## 기능 요구 사항
- 요구사항 - 로그인
- 로그인 기능 만들기
   - 특정 기능은 로그인을 해야만 가능 할 때가 있습니다.
      - 예 : 댓글, 좋아요/싫어요, 회원 글쓰기 등록, 결제 등
   - 회원의 아이디와 비밀번호를 입력받아 회원의 로그인 여부를 확인하고 로그인 서비스 제공
   - 명령어 : login (또는 signin)
   - 회원의 아이디, 비밀번호를 입력받아 회원 저장소의 정보와 모두 일치하는지 확인
   - 로그인 실패시 : 로그인 실패 메시지
   - 로그인 성공시 : 해당 유저의 이름으로 환영메시지 출력 후 해당 유저의 정보를 로그인 유저 정보에 저장

- 입출력예시
```
명령어를 입력해주세요 : signup

==== 회원 가입을 진행합니다 ====
아이디를 입력해주세요 : hong123
비밀번호를 입력해주세요 : h1234
닉네임을 입력해주세요 : 홍길동

==== 회원가입이 완료되었습니다. ====

명령어를 입력해주세요 : signin
아이디 : dfdfdf
비밀번호 : aaaadf
비밀번호를 틀렸거나 잘못된 회원정보입니다.
아이디 : hong123
비밀번호 : h1234
홍길동님 환영합니다!
명령어를 입력해주세요[hong123(홍길동)] : list
[게시물 목록]
  ```