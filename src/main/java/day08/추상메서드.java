package day08;

public class 추상메서드 {
    public static void main(String[] args) {
        // 1. 상속 -> 다형성개념을 알게됨. (상카class생성 -> 공통기능으로 넣어 ->
        // 상속후 수정사용 ->  상카객체.공통기능()으로 일괄처리가능 + 일괄처리시 분기문같이 각자 적용)
        경차 경차1 = new 경차();
        세단 세단1 = new 세단();

        //2. 상카객체에 담는 다형성으로 -> 상카객체 배열에 넣어 일괄처리 ->
        // but 공통기능 수정사용(Override)으로 내부에서 분기별 처리
        자동차 자동차1 = 경차1;
        자동차 자동차2 = 세단1;
        //5. 새로운 하카 객체 상카Type 변수에 추가로 담기
        자동차 자동차3 = new SUV();
        // 자동차[] 자동차들 = {자동차1, 자동차2};
        자동차[] 자동차들 = {자동차1, 자동차2, 자동차3};
        for (자동차 자동차 : 자동차들) {
            자동차.달리다();
        }
        //7. [추가조건]으로 모두 부모와는 서로 다르게 구현해야한다?
        // -> 필요시 [공통기능으로 수정사용] 안필요하면 <코드생략하고 상속>해서 그대로 사용
        // -> but [추가조건]으로 하카들이 서로 다르게 구현해야한다면? 상속된 것 못사용 한다.
        // -> 부모에 구현부가 있을 필요가 없다.
        // -> **부모 구현부 삭제하면, 어떻게든 강제로 [수정사용하도록 구현]된다.**
        // -> 8.로 가서 부모(상카)구현부 삭제하자.

        //10. 추가로, 부모의 공통기능 구현부를 삭제 -> 오버라이딩만 하면 자동 수정사용입니다. but
        // -> 부모의 공통기능을 오버라이딩 안하고, 지멋대로 쓸 수도 있다.
        // --> 공통기능 오버라이딩 안하면, 일괄처리시 호출이 안되기 때문에, 부모의 [공통기능을 반드시 사용하도록 강제] 할 필요가 있다
        // -> 11. 로 <하카Class별 내부분기처리>를 위해 <구현부를 비워두고 오버라이딩을 강제하는> [추상메서드]를 만들자.

        // -> 13. 추상메서드 -> 1개라도 있으면 추상클래스 -> 추상클래스를 상속했으면, 1개이상 있는 추상메서드를 반드시 오버라이딩 해야한다.

        // 14. my)  하위 카테고리Class별 내부 분기처리  일괄로 & [강제로 수행]하기 위해서
        //  [일반class의 상속]이 아니라  상카의 [구현부삭제된 공통기능 메서드]를 반드시 오버라이딩해서 써야하는 [추상메서드 in 추상클래스]를 만들어 상속한다.


        //3. 상속-다형성에 추가조건이 붙는다면?
        // -> 모든 자동차는 서로 다르게 달려야한다 -> 내부 분기별 구현이 모두 달라야한다.
        // -> 4. 추가
    }
}

//12. 생각해보니, 구현부가 없는 메서드를 가진 객체를 만들면 안된다.
// -> (구현없는 기능없는)추상메서드가 있으면, Class가 객체를 만들지 못하도록 -> [추상클래스]를 만든다.
// class 자동차 {
abstract class 자동차 {
    // 8. 하카들은 모두 다르게 공통기능을 수정해서 사용해야한다면,
    // -> 부모의 공통기능 구현부는 필요가 없다 ( 선언부는 반드시 필요.)
    // 11. <하카Class별 내부분기처리>를 위한 [추상메서드] -> class도 추상클래스가 된다.
    // void 달리다() {};
    abstract void 달리다();
        // System.out.println("자동차가 달립니다.");
}

class 경차 extends 자동차 {
    // 공통기능 수정사용 -> 일괄처리시 각자 다르게 적용될 구현부 작성
    @Override
    void 달리다() {
        System.out.println("경차가 경쾌하게 달립니다.");
    }

    void 연비절감() {
        System.out.println("연비가 절감됩니다.");
    }
}

class 세단 extends 자동차 {
    // 공통기능 수정사용 -> 일괄처리시 각자 다르게 적용될 구현부 작성
    @Override
    void 달리다() {
        System.out.println("세단이 우아하게 달립니다.");
    }

    void 안정된주행() {
        System.out.println("차가 정숙합니다.");
    }
}


//4.추가
class SUV extends 자동차 {
    // 공통기능 수정사용 -> 일괄처리시 각자 다르게 적용될 구현부 작성
    // 추가조건이 붙어서 -> 공통기능을 반드시 상속받은 것과 다르게 구현해줘야한다.
    // -> 일괄처리하려면, 메소드이름을 바꾸면 안된다!! 같은이름의 수정사용하는 공통기능 -> 일괄처리
    @Override
    void 달리다() {
        System.out.println("SUV가 힘차게 달립니다.");
    }

    // 하카만의 추가 기능
    void 많은적재() {
        System.out.println("짐을 많이 싣습니다.");
    }
}
