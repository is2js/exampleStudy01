package day08;

public class InterfaceClassTest {
    public static void main(String[] args) {
        // 6. 인터페이스 사용이유:
        // 사람----------[ 인터페이스(리모콘) - (TV내부)   ]
        // -> 나는 인터페이스(리모콘)만 조작할 수 있음 됨.
        // -> TV제작자는 TV를 인터페이스(리모콘)에 맞게 제작만 하면 됨.
        // -> TV제작자는 TV를 다른모델TV로 편하게 교체가능. 리모콘이랑 연결만 되면 됨.

        // 7. 자바에서 인터페이스가 필요한 이유
        // 개발자1, ---------[기능1]----------개발자2
        // -> 기능1 만드는데,
        // -> 개발자1-Aclass--[기능1]--Bclass-개발자2  로서, 2개의 클래스가모두 필요한 상황이다.
        // -> Aclass에서 Bclass의 기능funB1을 써야함
        // -> 개발자2가 만도안하고 funB1의 이름을 funB2로 바꿨다면? -> 개발자1은 Aclass개발이 안된다.
        // -> 그래서 Aclass <----> Bclass 중간에  리모콘처럼 적어둔다.
        // --> 리모콘: 기능마다 "함수이름 + 매개변수 + 리턴값 "을 적어주고, 이것만은 변동이 없게 한다.
        // -->    + 기능의 내부구현은 개발자2가 알아서 짤테니까, 개발자1은 "함수이름+매개변수+리턴값"을 이용해서 Aclass 완성만 시키면 된다.
        // -->    + 아직 기능구현이 안됬더라도, 쉬지말고 "이름+매개변수+리턴값"은 적어준데로 쓸테니까, 먼저 사용하는 척해라.
        // ----> 개발자1은 인터페이스만 보고, <있따고 가정>하고 쓰면 된다. 개발자2는 언젠간 개발끝낼 것이다.
        // my) 인터페이스를 사용하는 사람은, 있다고 가정하고 쓰고, 구현하는 사람은 실행전까지 구현해준다.
        // -> 자바에게도 Aclass와 Bclass는 중간에 Interface를 따른다는 것을 알려줘야한다.
        // -> 8.에서 코드로 설명 시작.

        // 9. B(객체->메서드)에 의존하는 A Class의 기능 바로 사용하기
        // -> 혼자 만들땐 상관없다.. 괜찮다...
        A a = new A();
        a.test(); //1

        //10. 근데, 둘이서 일한다면
        // -> B의 메서드에 의존하는 A지만, A는 B가 내부 구현을 안했다, 메소드를 안만들었다면?
        // -> A는 func1()이라는 이름도 모른다. -> b.????
        // -> A는 계속 쪼으면서 알려달라고 한다. -> 이름만 안다고 해서 아직 구현안된 것을 호출할 수도 없다.
        // -> 이 문제는 어떻게 해결?

        //11. A->B의존관계인 class들 사이에 인터페이스를 만들어서, 아직 미구현이라도 일진행되도록 해보자.
        //-> 12. ~ 16.

        //17. 인터페이스로 하면 뭐가 좋을까
        // -> 남이 짠 코드(구조)에  <interface로 미완성 구현>된 추메 구현부를 내가 짤 수 있음
        // [ 복잡1A-> 복잡2A -> interface ( -> 미완이지만 강제구현한 메소드B() ) -> 복잡3A ->복잡4A ]
        // -> 코드구조는 안건들고, A로직들이 <미완성 될지라도 B>를 호출할수 있게 [강제]하는 interface로 쫘놨으니
        // -> <B 미완성 구현>은 내가 완성할 수 있다.

        //18. my) class간 의존하고 있는 메소드를 <미완성 됫을지라도, 변경될지라도> 호출하는 구조를 짜게 해주는 Interface
    }
}
//12. A->B 의존관계를 해결할 interface 생성
interface test {
    // 1) A가 의존하고 있는 BClass쪽의 메소드를 구현부(기능)없는 추상메소드로 선언한다.
    // -> why? 개발자2(B)는 언제개발할지 모름. 개발자1(A)은 있던없던 가정하고 써야됨.
    int func1();
    // 2) 이제 언제개발될지모르는 메서드를 가진 class B로 가서 interface를 구현하게 한다.
    // -> 13. 14.
}


abstract class Test {
    // 1. class를 하나 만들고, 그 기능을 구현부 없는 abstract로 만든다.
    // -> **구현할내용이 달라서(하카별 내부분기처리 예정) 당장 결정할 수는 것들 -> abstract메서드라고 생각하자.**
    // -> 1개라도 추상메서드면 -> 추상클래스(객체생성금지)로 만들어야한다.
    abstract void func1();

    // 2. 2번째 메소드도 추상메서드로 만들어보자.
    abstract void func2();
    // 3. 3번째 메소드 역시, 하카별 구현내용이 서로 다르게 상속한 하카별분기처리 될거라... 구현부없는 추상메서드로 만들자
    abstract void func3();

    // 4. 모든 메소드가 추상메소드인 것(강제)을 -> 추상클래스가 아닌 Interface라 부른다.


}

// 8. A와 Bclass가 있다.
// 1) B class에서는 1을 return하는 메서드 func1이 있음.
// 2)  A에서는 B객체->B.func1()의   [B메서드사용을 위한 B객체생성 -> B메서드사용]을 한 뒤, 리턴받은 값을 출력한다.
//  ->  my) A는 Bclass객체 및 메서드에 의존하는 중.
class A {
    //2)
    void test() {
        // 15. 이제 interface -> B가 구현 -> B는 미완성이라도 반드시 추메를 구현해야하는 강제성으로
        // -> B가 interface를 <미완성이라도>구현하는 한, 무조건 인페속 추메()를 -> B객체.추메명()으로  쓸수 있다.
        B b = new B();
        int result = b.func1();
        System.out.println(result);
    }
}

// class B {
//13.
class B implements test {
    //1)
    //14. 언제 개발될진 모른다고 했지만, [interface에 잇는 추메를 미완성이라도 구현]은 해놓아야한다.
    // -> 참고로 구현한 메소드는 public이 꼭 붙어야한다.
    public int func1(){
        // 16. B는 미완성이라도 구현만 -> 추메선언부만 유지한체, 내부구현은 계속 바꿀 수 있다.(A입장에선 코드구조 변경없이 의존B메서드의 구현부에 따라 구현달라짐. 코드변경은 없다)
        return 1;
    }
}

interface TestInterface {
    // 5. 구현부없는 추상메소들이 기본이라, abstract를 따로 안붙여도 된다.
    // - {} 구현부를 넣으면 에러남.
    // -> 왜 쓸까?
    void func1();

    void func2();

    void func3();
}
