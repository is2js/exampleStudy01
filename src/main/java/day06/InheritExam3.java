package day06;

public class InheritExam3 {
    public static void main(String[] args) {
        동물 a동물 = new 동물();
        a동물.숨쉬다();

        고양이 a고양이 = new 고양이();
        a고양이.숨쉬다();

        강아지 a강아지 = new 강아지();
        a강아지.숨쉬다();
        
        // 부모class 상위 카테고리는 필수기능, 공통기능이지만
        // 자식class 하위 카테고리는 상속&메소드추가or재정의하면서, 하위카테고리만의 기능이 생겼지만
        // -> 그 새로생긴 기능=method의 사용법(이름, 파라미터)등을 각각 알고 있어야한다.

        // 하위 카테고리를 묶어서 상위 카테고리처럼 다루고 싶다. -> 다형성
        // -> 일일히 컨트롤 + 사용법 알아야됨은 쉽지가 않음.
        // -> 개별 특징(새로운 기능 or 수정된 기능)이 아니라
        // ****하위카테고리라도 공통기능만을 다룬다면, 상위 카테고리로서 다루어질 수 있다.**** -> 다형성으로서 부모class 참조변수에 담긴다.
        // -> ****대신 개별 추가/수정된 기능은 포기해야한다(에러남)**** -> 부모class(상위카테고리)참조변수에 담겼다면, 하위 기능(method)호출이 안된다.
        동물 b강아지 = new 강아지();
        // b강아지.멍멍(); // Error. 부모(상위)참조변수에 담겼따면 하위의 새로운 기능은 호출할 수 없다.
        동물 b고양이 = new 고양이();
        // b강아지.야옹(); // Error. 부모(상위)참조변수에 담겼따면 하위의 새로운 기능은 호출할 수 없다.

        // 다형성 쓰는 이유?
        // -> 똑같은 방식으로 다루기 위해 == 한 배열에 담기 위해
        동물[] 동물들 = new 동물[]{a동물, b강아지, b고양이};
        for (동물 동물 : 동물들) {
            동물.숨쉬다();
        }

        // -> 공통기능 or 수정된 공통기능만 쓸 건데, 다형성 안쓰면.. 일일히  상카객체.숨쉬다(), 고양이.숨쉬다(), 강아지.숨쉬다() -> 일괄처리없이 모두 수동으로 100개 다 호출시켜줘야한다


    }
}
